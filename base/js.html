<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.38">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/imgs/favicon.ico"><title>JavaScript | 前端面试题</title><meta name="description" content="前端面试题整理">
    <link rel="modulepreload" href="/interview-questions/assets/app.572dc05b.js"><link rel="modulepreload" href="/interview-questions/assets/js.html.db45e831.js"><link rel="modulepreload" href="/interview-questions/assets/js.html.e5486590.js">
    <link rel="stylesheet" href="/interview-questions/assets/style.23fbbacf.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/interview-questions/" class=""><img class="logo" src="/interview-questions/imgs/logo.svg" alt="前端面试题"><span class="site-name can-hide">前端面试题</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/interview-questions/base/" class="router-link-active" aria-label="🪛 前端基础"><!--[--><!--]--> 🪛 前端基础 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/interview-questions/senior/" class="" aria-label="🪜 前端进阶"><!--[--><!--]--> 🪜 前端进阶 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/interview-questions/skill/" class="" aria-label="🗡️ 面试技巧"><!--[--><!--]--> 🗡️ 面试技巧 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/RhysZhao/interview-questions" rel="noopener noreferrer" target="_blank" aria-label="点亮⭐收藏"><!--[--><!--]--> 点亮⭐收藏 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="Search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/interview-questions/base/" class="router-link-active" aria-label="🪛 前端基础"><!--[--><!--]--> 🪛 前端基础 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/interview-questions/senior/" class="" aria-label="🪜 前端进阶"><!--[--><!--]--> 🪜 前端进阶 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/interview-questions/skill/" class="" aria-label="🗡️ 面试技巧"><!--[--><!--]--> 🗡️ 面试技巧 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/RhysZhao/interview-questions" rel="noopener noreferrer" target="_blank" aria-label="点亮⭐收藏"><!--[--><!--]--> 点亮⭐收藏 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active">前端基础 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/interview-questions/base/" class="router-link-active sidebar-item" aria-label="前言"><!--[--><!--]--> 前言 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/interview-questions/base/js.html#_1-面试官-说说-javascript-中的数据类型-如何区分" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 面试官：说说 Javascript 中的数据类型？如何区分?"><!--[--><!--]--> 1. 面试官：说说 Javascript 中的数据类型？如何区分? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_2-面试官-javscript-数组的常用方法有哪些" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 面试官：JavScript 数组的常用方法有哪些？"><!--[--><!--]--> 2. 面试官：JavScript 数组的常用方法有哪些？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_3-面试官-javascript-字符串的常用方法有哪些" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. 面试官：Javascript 字符串的常用方法有哪些？"><!--[--><!--]--> 3. 面试官：Javascript 字符串的常用方法有哪些？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_4-面试官-谈谈-javascript-中的类型转换机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="4. 面试官：谈谈 JavaScript 中的类型转换机制"><!--[--><!--]--> 4. 面试官：谈谈 JavaScript 中的类型转换机制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_5-面试官-、-和-object-is-三者的区别-分别在什么情况使用" class="router-link-active router-link-exact-active sidebar-item" aria-label="5. 面试官：== 、 === 和 Object.is()三者的区别，分别在什么情况使用？"><!--[--><!--]--> 5. 面试官：== 、 === 和 Object.is()三者的区别，分别在什么情况使用？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_6-面试官-深拷贝浅拷贝的区别-如何实现一个深拷贝" class="router-link-active router-link-exact-active sidebar-item" aria-label="6. 面试官：深拷贝浅拷贝的区别？如何实现一个深拷贝？"><!--[--><!--]--> 6. 面试官：深拷贝浅拷贝的区别？如何实现一个深拷贝？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_7-面试官-说说你对闭包的理解" class="router-link-active router-link-exact-active sidebar-item" aria-label="7. 面试官：说说你对闭包的理解*************"><!--[--><!--]--> 7. 面试官：说说你对闭包的理解************* <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_8-面试官-说说你对作用域链的理解" class="router-link-active router-link-exact-active sidebar-item" aria-label="8. 面试官：说说你对作用域链的理解"><!--[--><!--]--> 8. 面试官：说说你对作用域链的理解 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_9-面试官-javascript-原型-原型链-有什么特点" class="router-link-active router-link-exact-active sidebar-item" aria-label="9. 面试官：JavaScript 原型，原型链 ? 有什么特点？"><!--[--><!--]--> 9. 面试官：JavaScript 原型，原型链 ? 有什么特点？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_10-面试官-javascript-如何实现继承" class="router-link-active router-link-exact-active sidebar-item" aria-label="10. 面试官：Javascript 如何实现继承？"><!--[--><!--]--> 10. 面试官：Javascript 如何实现继承？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_11-面试官-谈谈-this-对象的理解" class="router-link-active router-link-exact-active sidebar-item" aria-label="11. 面试官：谈谈 this 对象的理解"><!--[--><!--]--> 11. 面试官：谈谈 this 对象的理解 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_12-面试官-javascript-中执行上下文和执行栈是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="12. 面试官：JavaScript 中执行上下文和执行栈是什么？"><!--[--><!--]--> 12. 面试官：JavaScript 中执行上下文和执行栈是什么？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_13-面试官-说说-javascript-中的事件模型-事件传播机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="13. 面试官：说说 JavaScript 中的事件模型(事件传播机制)"><!--[--><!--]--> 13. 面试官：说说 JavaScript 中的事件模型(事件传播机制) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_14-面试官-解释下什么是事件代理-应用场景" class="router-link-active router-link-exact-active sidebar-item" aria-label="14. 面试官：解释下什么是事件代理？应用场景？"><!--[--><!--]--> 14. 面试官：解释下什么是事件代理？应用场景？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_15-面试官-typeof-与-instanceof-区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="15. 面试官：typeof 与 instanceof 区别"><!--[--><!--]--> 15. 面试官：typeof 与 instanceof 区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_16-面试官-说说-new-操作符具体干了什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="16. 面试官：说说 new 操作符具体干了什么？"><!--[--><!--]--> 16. 面试官：说说 new 操作符具体干了什么？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_17-面试官-ajax-原理是什么-如何实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="17. 面试官：ajax 原理是什么？如何实现？"><!--[--><!--]--> 17. 面试官：ajax 原理是什么？如何实现？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_18-面试官-bind、call、apply-区别-如何实现一个-bind" class="router-link-active router-link-exact-active sidebar-item" aria-label="18. 面试官：bind、call、apply 区别？如何实现一个 bind?"><!--[--><!--]--> 18. 面试官：bind、call、apply 区别？如何实现一个 bind? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_19-面试官-说说你对正则表达式的理解-应用场景" class="router-link-active router-link-exact-active sidebar-item" aria-label="19. 面试官：说说你对正则表达式的理解？应用场景？"><!--[--><!--]--> 19. 面试官：说说你对正则表达式的理解？应用场景？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_20-面试官-说说你对事件循环的理解" class="router-link-active router-link-exact-active sidebar-item" aria-label="20. 面试官：说说你对事件循环的理解"><!--[--><!--]--> 20. 面试官：说说你对事件循环的理解 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_21-面试官-dom-常见的操作有哪些" class="router-link-active router-link-exact-active sidebar-item" aria-label="21. 面试官：DOM 常见的操作有哪些？"><!--[--><!--]--> 21. 面试官：DOM 常见的操作有哪些？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_22-面试官-说说你对-bom-的理解-常见的-bom-对象你了解哪些" class="router-link-active router-link-exact-active sidebar-item" aria-label="22. 面试官：说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？"><!--[--><!--]--> 22. 面试官：说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_23-面试官-举例说明你对尾递归的理解-有哪些应用场景" class="router-link-active router-link-exact-active sidebar-item" aria-label="23. 面试官：举例说明你对尾递归的理解，有哪些应用场景"><!--[--><!--]--> 23. 面试官：举例说明你对尾递归的理解，有哪些应用场景 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_24-面试官-说说-javascript-中内存泄漏的几种情况" class="router-link-active router-link-exact-active sidebar-item" aria-label="24. 面试官：说说 JavaScript 中内存泄漏的几种情况？"><!--[--><!--]--> 24. 面试官：说说 JavaScript 中内存泄漏的几种情况？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_25-面试官-javascript-本地存储的方式有哪些-区别及应用场景" class="router-link-active router-link-exact-active sidebar-item" aria-label="25. 面试官：Javascript 本地存储的方式有哪些？区别及应用场景？"><!--[--><!--]--> 25. 面试官：Javascript 本地存储的方式有哪些？区别及应用场景？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_26-面试官-说说你对函数式编程的理解-优缺点" class="router-link-active router-link-exact-active sidebar-item" aria-label="26. 面试官：说说你对函数式编程的理解？优缺点？"><!--[--><!--]--> 26. 面试官：说说你对函数式编程的理解？优缺点？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_27-面试官-javascript-中如何实现函数缓存-函数缓存有哪些应用场景" class="router-link-active router-link-exact-active sidebar-item" aria-label="27. 面试官：Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？"><!--[--><!--]--> 27. 面试官：Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_28-面试官-说说-javascript-数字精度丢失的问题-如何解决" class="router-link-active router-link-exact-active sidebar-item" aria-label="28. 面试官：说说 Javascript 数字精度丢失的问题，如何解决？"><!--[--><!--]--> 28. 面试官：说说 Javascript 数字精度丢失的问题，如何解决？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_29-面试官-什么是防抖和节流-有什么区别-如何实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="29. 面试官：什么是防抖和节流？有什么区别？如何实现？"><!--[--><!--]--> 29. 面试官：什么是防抖和节流？有什么区别？如何实现？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_30-面试官-如何判断一个元素是否在可视区域中" class="router-link-active router-link-exact-active sidebar-item" aria-label="30. 面试官：如何判断一个元素是否在可视区域中？"><!--[--><!--]--> 30. 面试官：如何判断一个元素是否在可视区域中？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_31-面试官-大文件上传如何做断点续传" class="router-link-active router-link-exact-active sidebar-item" aria-label="31. 面试官：大文件上传如何做断点续传？"><!--[--><!--]--> 31. 面试官：大文件上传如何做断点续传？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_32-面试官-如何实现上拉加载-下拉刷新" class="router-link-active router-link-exact-active sidebar-item" aria-label="32. 面试官：如何实现上拉加载，下拉刷新？"><!--[--><!--]--> 32. 面试官：如何实现上拉加载，下拉刷新？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_33-面试官-什么是单点登录-如何实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="33. 面试官：什么是单点登录？如何实现？"><!--[--><!--]--> 33. 面试官：什么是单点登录？如何实现？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview-questions/base/js.html#_34-面试官-web-常见的攻击方式有哪些-如何防御" class="router-link-active router-link-exact-active sidebar-item" aria-label="34. 面试官：web 常见的攻击方式有哪些？如何防御？"><!--[--><!--]--> 34. 面试官：web 常见的攻击方式有哪些？如何防御？ <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/interview-questions/base/es6.html" class="sidebar-item" aria-label="ES6"><!--[--><!--]--> ES6 <!--[--><!--]--></a><!----></li><li><a href="/interview-questions/base/css.html" class="sidebar-item" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!----></li><li><a href="/interview-questions/base/http.html" class="sidebar-item" aria-label="HTTP"><!--[--><!--]--> HTTP <!--[--><!--]--></a><!----></li><li><a href="/interview-questions/base/react.html" class="sidebar-item" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><!----></li><li><a href="/interview-questions/base/webpack.html" class="sidebar-item" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!----></li><li><a href="/interview-questions/base/design-mode.html" class="sidebar-item" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a><!----></li><li><a href="/interview-questions/base/git.html" class="sidebar-item" aria-label="git"><!--[--><!--]--> git <!--[--><!--]--></a><!----></li><li><a href="/interview-questions/base/algorithm.html" class="sidebar-item" aria-label="算法"><!--[--><!--]--> 算法 <!--[--><!--]--></a><!----></li><li><a href="/interview-questions/base/operation-system.html" class="sidebar-item" aria-label="操作系统"><!--[--><!--]--> 操作系统 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="javascript" tabindex="-1"><a class="header-anchor" href="#javascript" aria-hidden="true">#</a> JavaScript</h1><h2 id="_1-面试官-说说-javascript-中的数据类型-如何区分" tabindex="-1"><a class="header-anchor" href="#_1-面试官-说说-javascript-中的数据类型-如何区分" aria-hidden="true">#</a> 1. 面试官：说说 Javascript 中的数据类型？如何区分?</h2><p>Javascript 数据类型分为简单类型和引用类型。<br> 简单数据类型有 6 种: number, string, null, undefined, boolean, symbol<br> 引用类型只有一种 object, 包括数组、对象和函数。<br></p><p>基本类型数据保存在在栈内存中。<br> 引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中。<br></p><p>需要注意的是,我们在声明的时候并不能确认数据类型，只有到运行期间才会确定当前类型。<br> 确认数据类型的话，可以使用 <code>typeOf</code>。但是 <code>typeof(null)</code> 会返回 object，并且 typeof 不能区分函数、数组和对象。<br> 比较推荐用 <code>Object.prototype.toString.call()</code>来判断, 能够精确的返回数据的类型,包括日期/正则表达式/函数类型。</p><p>代码如下:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>typeof(null) // object
Object.prototype.toString.call(null) // [object Null]
Object.prototype.toString.call([]) // [object Array]
Object.prototype.toString.call({}) // [object Object]
Object.prototype.toString.call(3) // [object Number]
Object.prototype.toString.call(&#39;test&#39;) // [object String]
Object.prototype.toString.call(/^abc/) // [object RegExp]
Object.prototype.toString.call(new Date()) // [object Date]
Object.prototype.toString.call(() =&gt; {})) // [object Function]
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_2-面试官-javscript-数组的常用方法有哪些" tabindex="-1"><a class="header-anchor" href="#_2-面试官-javscript-数组的常用方法有哪些" aria-hidden="true">#</a> 2. 面试官：JavScript 数组的常用方法有哪些？</h2><ul><li>增： <code>push</code>: 向数组末尾插入任意数量的参数。返回数组的最新长度。改变原有数组。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let colors = [&#39;red&#39;];
const len = colors.push(&#39;green&#39;, &#39;blue&#39;);
console.log(len); // 3
console.log(colors); // [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>unshift</code>: 向数组开头插入任意数量的参数。返回数组的最新长度。改变原有数组。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let colors = [&#39;red&#39;];
const len = colors.unshift(&#39;green&#39;, &#39;blue&#39;);
console.log(len); // 3
console.log(colors); // [&#39;green&#39;, &#39;blue&#39;, &#39;red&#39;]
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>splice</code>: 传入三个参数，分别是开始位置，删除的元素个数，插入的元素。返回删除元素组成的数组。改变原有数组。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let colors = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;];
let removeList = colors.splice(1, 0, &#39;yellow&#39;, &#39;black&#39;);
console.log(removeList); // []
console.log(colors); // [&#39;red&#39;,&#39;yellow&#39;, &#39;black&#39;, &#39;green&#39;, &#39;blue&#39;]
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>concat</code>: 创建一个当前数组的副本，并把参数添加到副本末尾。常用来合并多个数组。不改变原有数组。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let colors = [&#39;red&#39;];
let newColors = colors.concat(&#39;green&#39;, &#39;blue&#39;, [&#39;yellow&#39;]);
console.log(newColors); // [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;yellow&#39;]
console.log(colors); // [&#39;red&#39;]
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>删： <code>pop</code>: 删除数组的最后一个元素。返回被删除的元素。改变原有数组。 <code>shift</code>: 删除数组的第一个元素。返回被删除的元素。改变原有数组。 <code>splice</code>: 改变原有数组。返回被删除元素组成的数组。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let colors = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;];
let removeList = colors.splice(1, 2);
console.log(removeList); // [&#39;green&#39;, &#39;blue&#39;]
console.log(colors); // [&#39;red&#39;]
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>slice</code>: 分割数组，不影响原有数组。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let colors = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;yellow&#39;, &#39;orange&#39;, &#39;pink&#39;];
let newColors = colors.slice(2, 4);
console.log(newColors); // [&#39;blue&#39;, &#39;yellow&#39;]
console.log(colors); // [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;yellow&#39;, &#39;orange&#39;, &#39;pink&#39;]
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>改： <code>splice</code>：同上面。返回被删除元素的数组。改变原有数组</li><li>查： <code>indexOf</code>: 返回要查找的元素在数组中的位置，如果没找到则返回 -1 <code>includes</code>: 数组是否包含某个元素。返回 true 或 false <code>find</code>: 查找满足某个条件的元素。返回第一个满足条件的元素。 <code>findIndex</code>: 查找满足某个条件的元素索引。返回第一个满足条件的元素索引。</li><li>排序： <code>reverse</code>: 反转数组。改变原有数组。返回新数组。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let a = [1, 2, 3, 4, 5];
let newArr = a.reverse();
console.log(newArr); // [5, 4, 3, 2, 1]
console.log(a); // [5, 4, 3, 2, 1]
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>sort</code>: 数组排序。改变原有数组。返回新数组。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let a = [1, 2, 3, 4, 5];
let newArr = a.sort((x, y) =&gt; y - x);
console.log(newArr); // [5, 4, 3, 2, 1]
console.log(a); // [5, 4, 3, 2, 1]
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>迭代(都不改变原有数组)： <code>forEach</code>: 对数组的每一项都运行传入的函数。没有返回值。 <code>map</code>: 对数组的每一项都运行传入的函数。返回每次结果组成的新数组。 <code>filter</code>: 对数组的每一项都运行传入的函数。返回过滤后的数组。 <code>some</code>: 对数组的每一项都执行操作，如果有一个返回 true. 则结果就为 true <code>every</code>: 对数组的每一项都执行操作，只有所有项都返回 true. 结果才为 true</li></ul><p>转换(不改变原有数组)： <code>join</code>: 接收一个参数作为分隔符，分割数组所有元素。返回分割后的字符串。不传参默认分隔符为 <code>,</code></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let a = [1, 2, 3];
a.join(); // 1,2,3
a.join(&#39;|&#39;); // 1|2|3
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_3-面试官-javascript-字符串的常用方法有哪些" tabindex="-1"><a class="header-anchor" href="#_3-面试官-javascript-字符串的常用方法有哪些" aria-hidden="true">#</a> 3. 面试官：Javascript 字符串的常用方法有哪些？</h2><ul><li>增： <code>concat</code>: 用于将一个或多个字符串拼接成一个新字符串。不改变原字符串。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let str = &#39;hello&#39;;
let newStr = str.concat(&#39; &#39;, &#39;world&#39;, &#39;!&#39;);
console.log(newStr); // &#39;hello, world!&#39;
console.log(str); // &#39;hello&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><p>删(都不改变原有数组)： <code>slice</code>: 切割字符串。返回切割后的字符串。不改变原有字符串。 <code>substring</code>: 切割字符串。返回切割后的字符串。不改变原有字符串。 <code>substr</code>: 跟<code>substring</code>的区别是第二个参数是长度，而不是结束节点的索引。</p></li><li><p>改(都不改变原有数组)： <code>trim()、trimLeft()、trimRight()</code>: 去除空格。并返回新的字符串。 <code>repeat()</code>: 接收一个整数参数，表示要将字符串复制多少次，然后返回拼接后的结果 <code>padStart()、padEnd()</code>: 复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件. <code>toLowerCase()、 toUpperCase()</code>: 大小写转换。</p></li><li><p>查： <code>charAt</code>: 返回给定索引位置的字符.</p></li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&#39;hello&#39;.charAt(1); // &#39;e&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><code>at</code>: 返回给定索引位置的字符，支持负数。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&#39;hello&#39;.at(-1); // &#39;o&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><code>indexOf</code>: 从字符串开头去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ） <code>startWith</code>: 字符串是否以参数开头，返回 true 或 false. <code>includes</code>: 字符串是否包含 参数，返回 true 或 false.</p><ul><li>转换： <code>split</code>: 通过分隔符分割字符串，返回分割后元素的数组。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let str = &#39;test*test*test&#39;;
let strArr = str.split(&#39;*&#39;);
console.log(strArr);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_4-面试官-谈谈-javascript-中的类型转换机制" tabindex="-1"><a class="header-anchor" href="#_4-面试官-谈谈-javascript-中的类型转换机制" aria-hidden="true">#</a> 4. 面试官：谈谈 JavaScript 中的类型转换机制</h2><h2 id="_5-面试官-、-和-object-is-三者的区别-分别在什么情况使用" tabindex="-1"><a class="header-anchor" href="#_5-面试官-、-和-object-is-三者的区别-分别在什么情况使用" aria-hidden="true">#</a> 5. 面试官：== 、 === 和 <code>Object.is()</code>三者的区别，分别在什么情况使用？</h2><p>== 在比较中会先进行类型转换，再确定操作数是否相等。分以下几种情况：</p><ul><li>两个都为简单类型，字符串和布尔值都会转换成数值，再比较</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>2 == true // false
&#39;2&#39; == true // false
&#39;1&#39; == true // true
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>简单类型与引用类型比较，对象转化成其原始类型的值通过 <code>valueOf</code> 函数，再比较</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let a = { name: &#39;Jack&#39;, age: 18 };
Object.prototype.valueOf = () =&gt; 1;
a == 1; // true
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>两个都为引用类型，则比较它们是否指向同一个对象</li></ul><p>需要注意的是, null 和 undefined 相等。<br> NaN 跟谁都不相等。<br></p><p>=== 只有两个操作数在不转换的前提下相等才返回 true。即类型相同，值也需相同。</p><p><code>Object.is()</code>与 <code>===</code> 只有两处不同:</p><ul><li>+0 不等于-0</li><li>NaN 等于自身</li></ul><p>代码如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>+0 === -0 // true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_6-面试官-深拷贝浅拷贝的区别-如何实现一个深拷贝" tabindex="-1"><a class="header-anchor" href="#_6-面试官-深拷贝浅拷贝的区别-如何实现一个深拷贝" aria-hidden="true">#</a> 6. 面试官：深拷贝浅拷贝的区别？如何实现一个深拷贝？</h2><p>JavaScript 数据类型有两种：基本类型和引用类型。</p><p>基本类型数据保存在在栈内存中。<br> 引用类型数据保存在堆内存中，引用数据类型的变量存在栈中，指向堆内存中实际对象的地址。</p><p>当拷贝类型为引用类型的情况下：<br> 浅拷贝是拷贝一层，属性为对象时，拷贝对象和原对象指向同一个地址。一个对象的修改会影响另一个对象。<br> 深拷贝则是新开内存，拷贝对象和原对象指向不同的地址。因此也不会互相影响。</p><p>常用的方法，<code>Object.assign()</code>和扩展运算符<code>...</code>都属于浅拷贝。<br> 如果要实现深拷贝，有这样几个方法：</p><ul><li>JSON.parse(JSON.stringify()), 需要注意的是，如果深拷贝的对象是函数和 undefined 会报错</li><li>lodash.cloneDeep()</li><li>自己手写一个深拷贝方法。 具体方法就是利用递归，只要某个属性是对象类型，就递归；若是其他类型，则直接复制。代码如下：</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function deepCopy(data) {
    if (typeof data !== &#39;object&#39; || data === null) { // typeof null 的结果是 object
        return data
    }
    let result = Array.isArray(data) ? [] : {}
    for (let key in data) {
        // for...in 会遍历obj原型上的属性，因此需要用hasOwnProperty(key)来判断下当前属性是否属于obj
        if (data.hasOwnProperty(key)) {
            if (typeof data[key] === &#39;object&#39;) {
                result[key] = deepCopy(data[key])
            } else {
                result[key] = data[key]
            }
        }
    }
    return result
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="_7-面试官-说说你对闭包的理解" tabindex="-1"><a class="header-anchor" href="#_7-面试官-说说你对闭包的理解" aria-hidden="true">#</a> 7. 面试官：说说你对闭包的理解******<strong>*</strong>******</h2><p>函数嵌套，内部函数能够访问外部函数的局部变量。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function fun() {
    var count = 2
    return function() {
        console.log(count)
    }
}
fun()
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>优点：长外部函数局部变量生命周期 缺点：容易造成内存泄漏，被内部函数访问的变量需要手动回收</p><h2 id="_8-面试官-说说你对作用域链的理解" tabindex="-1"><a class="header-anchor" href="#_8-面试官-说说你对作用域链的理解" aria-hidden="true">#</a> 8. 面试官：说说你对作用域链的理解</h2><p>我们一般将作用域分成：全局作用域、函数作用域、块级作用域(ES6 新增)。</p><p>JavaScript 遵循的是静态作用域，变量被创建时作用域就确定了，而非执行阶段确定的。<br> 比如下面这段代码：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var a = 2;
function foo() {
    console.log(a)
}
function bar() {
    var a = 3;
    foo();
}
bar() // 输出2
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>当在 Javascript 中使用一个变量的时候，首先 Javascript 引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域.<br> 如果在全局作用域仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错</p><h2 id="_9-面试官-javascript-原型-原型链-有什么特点" tabindex="-1"><a class="header-anchor" href="#_9-面试官-javascript-原型-原型链-有什么特点" aria-hidden="true">#</a> 9. 面试官：JavaScript 原型，原型链 ? 有什么特点？</h2><p>首先需要知道的是，在 JavaScript 里，一切皆对象。</p><p>每个构造函数都有一个 prototype 属性，是一个对象，我们称之为原型对象。原型对象有个 constructor 属性，指向这个函数。<br> prototype 上的属性和方法可以被实例对象调用。<br></p><p>每个对象都有<code>__proto__</code>属性，指向其构造函数的原型对象。当我们使用对象的属性时候，如果本身不包含某个属性，就会到其构造函数的原型上查找，而构造函数的原型也是对象，也可以向上查找，直到 null 为止。</p><p>看图就明白了： <img src="https://upload-images.jianshu.io/upload_images/1745991-df4821f51e5f945a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""></p><h2 id="_10-面试官-javascript-如何实现继承" tabindex="-1"><a class="header-anchor" href="#_10-面试官-javascript-如何实现继承" aria-hidden="true">#</a> 10. 面试官：Javascript 如何实现继承？</h2><ul><li>构造函数继承：只能继承构造函数里的属性和方法<br> 其实就是在子构造函数里面调用父构造函数（需要修改 this 指向），这样就把父构造函数里的属性和方法放到了子构造函数里了。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(name, age) {
  this.name = name;
  this.age = age;
  this.say = function () {
    console.log(&#39;你好&#39;);
  };
}
Person.prototype.sing = function () {
  console.log(&#39;唱歌&#39;);
};

function Student(name, age, score) {
  Person.call(this, name, age); // 由于Person里的this指向为Person的实例，这里修改this指向为Student的实例
  this.score = score;
}

const jack = new Student(&#39;Jack&#39;, 18, 100);
console.log(jack.name); // Jack
jack.say(); // 你好
jack.sing(); // 无结果，Student没有继承Person原型上的方法
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><ul><li>原型链继承<br> 通过上面的例子我们可以看出，构造函数继承并不能继承原型链上的方法。那我们怎么才能继承父构造函数原型上的方法呢？<br> 我们可以把子构造函数原型指向父构造函数的原型。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Student.prototype = Person.prototype; // - 原始版 缺陷：Student的原型改变导致Person原型改变，因此不可取
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>原型一样，自然能够继承原型上的方法。 但是这样一来就会出现问题，原型是个对象，是引用类型数据，我们再 <strong>修改<code>Student.prototype</code>会导致<code>Person.prototype</code>的变化。这是不合理的。</strong> 比如：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Student.prototype.dance = function () {
  console.log(&#39;跳舞&#39;);
};

const jack = new Person(&#39;Jack&#39;, 18);
jack.dance(); // 跳舞    Person的原型上是没有dance方法的。这里是因为我们扩展了Student的原型导致Person原型变化
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>常用的解决办法是，我们将子构造函数的原型指向福构造函数的一个实例。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Student.prototype = new Person();
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><img src="https://upload-images.jianshu.io/upload_images/1745991-861aedc643cbeb93.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""></p><p>前面说过，调用一个函数的属性时，编译器会先看对象本身是否有这个属性，如果没有就到对象的<code>__proto__</code>属性上去找，如果还找不到，继续找<code>__proto__</code>的<code>__proto__</code>属性，直到 null 为止。这样一来，Student 实例就能够调用 Person 实例的方法，从而调用 Person 原型的方法。</p><ul><li>组合继承<br> 把构造函数继承和组合继承结合起来就是组合继承了。整体代码如下：</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(name, age) {
  this.name = name;
  this.age = age;
  this.say = function () {
    console.log(&#39;你好&#39;);
  };
}
Person.prototype.sing = function () {
  console.log(&#39;唱歌&#39;);
};

function Student(name, age, score) {
  Person.call(this, name, age);
  this.score = score;
}
Student.prototype = new Person();
Student.prototype.constructor = Student; // 修改constructor指向
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>组合继承调用了两次父构造函数，且每创建一个子构造函数，都会生成一个父构造函数实例。还是不够完美。</p><ul><li>寄生组合继承</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(name, age) {
  this.name = name;
  this.age = age;
  this.say = function () {
    console.log(&#39;你好&#39;);
  };
}
Person.prototype.sing = function () {
  console.log(&#39;唱歌&#39;);
};

function Student(name, age, score) {
  Person.call(this, name, age);
  this.score = score;
}
Student.prototype = Object.create(Person.prototype); // Object.create(proto)创建一个对象，这个对象的__proto__属性为proto
Student.prototype.constructor = Student; // 修改constructor指向
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><img src="https://upload-images.jianshu.io/upload_images/1745991-09fe4ca0e062f659.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""></p><p>Student 实例能够调用 Student 原型上的方法，而 Student 原型又可以通过<code>__proto__</code>获取 Person 原型上的方法。这样就实现了 Student 继承 Person 原型上的方法。</p><ul><li>使用类</li></ul><p>最好用的继承，自然是使用 ES6 里的 class:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Person {
    constructor(name, age) {
        this.name = name
        this.age = age
    }
    say() {
        console.log(this.name)
    }
}
class Student extends Person {
    ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>ES6 的 class 本质上还是函数。如果用 babel 转译后会发现，它会被转译成寄生组合继承。</p><h2 id="_11-面试官-谈谈-this-对象的理解" tabindex="-1"><a class="header-anchor" href="#_11-面试官-谈谈-this-对象的理解" aria-hidden="true">#</a> 11. 面试官：谈谈 this 对象的理解</h2><p>普通函数，this 指向调用它的那个对象。<br> 箭头函数，没有具体的 this,它的 this 相当于是从上下文继承的,也就是说定义时候的上下文 this(使用 call,apply 等任何方式都无法改变 this 的指向)。<br></p><p>改变 this 指向可以使用 call, bind, apply 方法改变。</p><h2 id="_12-面试官-javascript-中执行上下文和执行栈是什么" tabindex="-1"><a class="header-anchor" href="#_12-面试官-javascript-中执行上下文和执行栈是什么" aria-hidden="true">#</a> 12. 面试官：JavaScript 中执行上下文和执行栈是什么？</h2><h2 id="_13-面试官-说说-javascript-中的事件模型-事件传播机制" tabindex="-1"><a class="header-anchor" href="#_13-面试官-说说-javascript-中的事件模型-事件传播机制" aria-hidden="true">#</a> 13. 面试官：说说 JavaScript 中的事件模型(事件传播机制)</h2><p>js 事件传播有三个阶段：事件捕获、目标阶段、事件冒泡</p><ul><li>事件捕获阶段：事件从 document 一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li><li>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数</li><li>事件冒泡阶段：事件从目标元素冒泡到 document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行 一般情况下，默认都是冒泡阶段触发事件，因此事件触发的顺序是从内到外。 取消默认事件：W3C 的方法是 e.preventDefault()，IE 则是使用 e.returnValue = false</li></ul><h2 id="_14-面试官-解释下什么是事件代理-应用场景" tabindex="-1"><a class="header-anchor" href="#_14-面试官-解释下什么是事件代理-应用场景" aria-hidden="true">#</a> 14. 面试官：解释下什么是事件代理？应用场景？</h2><pre><code>利用事件冒泡的原理，把事件加到父级上，触发执行效果
好处：减少事件数量，提高性能
新添加的元素，依然可以触发该事件
比如一个页面有 100 个按钮，点击每个按钮都会触发某个操作。我们可以给这 100 个按钮的父级添加点击事件，然后再判断是哪个按钮，执行对应的操作。
</code></pre><h2 id="_15-面试官-typeof-与-instanceof-区别" tabindex="-1"><a class="header-anchor" href="#_15-面试官-typeof-与-instanceof-区别" aria-hidden="true">#</a> 15. 面试官：typeof 与 instanceof 区别</h2><h2 id="_16-面试官-说说-new-操作符具体干了什么" tabindex="-1"><a class="header-anchor" href="#_16-面试官-说说-new-操作符具体干了什么" aria-hidden="true">#</a> 16. 面试官：说说 new 操作符具体干了什么？</h2><pre><code>创建一个空对象
由 this 变量引用该对象
该对象继承构造函数的原型（更改 this 指向）
把属性和方法加入到 this 引用的对象
最后隐式的返回 this
</code></pre><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let obj = {}
obj.__proto__ = Person.prototype
Person.call(obj)
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_17-面试官-ajax-原理是什么-如何实现" tabindex="-1"><a class="header-anchor" href="#_17-面试官-ajax-原理是什么-如何实现" aria-hidden="true">#</a> 17. 面试官：ajax 原理是什么？如何实现？</h2><h2 id="_18-面试官-bind、call、apply-区别-如何实现一个-bind" tabindex="-1"><a class="header-anchor" href="#_18-面试官-bind、call、apply-区别-如何实现一个-bind" aria-hidden="true">#</a> 18. 面试官：bind、call、apply 区别？如何实现一个 bind?</h2><pre><code>call, apply 和 bind 是 Function 原型上的三个方法，都是为了改变函数体内部 this 的指向。
call、apply、bind 三者第一个参数都是 this 要指向的对象，后面的参数 call 是一个个的参数列表，apply 则是放到数组中的
bind 是返回一个函数，便于稍后调用。call, apply 则是立即调用
</code></pre><h2 id="_19-面试官-说说你对正则表达式的理解-应用场景" tabindex="-1"><a class="header-anchor" href="#_19-面试官-说说你对正则表达式的理解-应用场景" aria-hidden="true">#</a> 19. 面试官：说说你对正则表达式的理解？应用场景？</h2><h2 id="_20-面试官-说说你对事件循环的理解" tabindex="-1"><a class="header-anchor" href="#_20-面试官-说说你对事件循环的理解" aria-hidden="true">#</a> 20. 面试官：说说你对事件循环的理解</h2><pre><code>js 执行时，遇到同步任务，就将同步任务按照执行顺序排列到执行栈中。
遇到异步任务，会将此类异步任务挂起，继续执行执行栈中的任务。等异步任务返回结果后，再按照顺序排列到事件队列中。
主线程先将执行栈中的同步任务清空，然后检查事件队列中是否有任务，如果有，就将第一个事件对应的回调推到执行栈中执行，若在执行过程中遇到异步任务，则继续将这个异步任务排列到事件队列中。
主线程每次将执行栈清空后，就去事件队列中检查是否有任务，如果有，就每次取出一个推到执行栈中执行，这个循环往复的过程被称为“Event Loop 事件循环”。
</code></pre><h2 id="_21-面试官-dom-常见的操作有哪些" tabindex="-1"><a class="header-anchor" href="#_21-面试官-dom-常见的操作有哪些" aria-hidden="true">#</a> 21. 面试官：DOM 常见的操作有哪些？</h2><h2 id="_22-面试官-说说你对-bom-的理解-常见的-bom-对象你了解哪些" tabindex="-1"><a class="header-anchor" href="#_22-面试官-说说你对-bom-的理解-常见的-bom-对象你了解哪些" aria-hidden="true">#</a> 22. 面试官：说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？</h2><h2 id="_23-面试官-举例说明你对尾递归的理解-有哪些应用场景" tabindex="-1"><a class="header-anchor" href="#_23-面试官-举例说明你对尾递归的理解-有哪些应用场景" aria-hidden="true">#</a> 23. 面试官：举例说明你对尾递归的理解，有哪些应用场景</h2><h2 id="_24-面试官-说说-javascript-中内存泄漏的几种情况" tabindex="-1"><a class="header-anchor" href="#_24-面试官-说说-javascript-中内存泄漏的几种情况" aria-hidden="true">#</a> 24. 面试官：说说 JavaScript 中内存泄漏的几种情况？</h2><h2 id="_25-面试官-javascript-本地存储的方式有哪些-区别及应用场景" tabindex="-1"><a class="header-anchor" href="#_25-面试官-javascript-本地存储的方式有哪些-区别及应用场景" aria-hidden="true">#</a> 25. 面试官：Javascript 本地存储的方式有哪些？区别及应用场景？</h2><h2 id="_26-面试官-说说你对函数式编程的理解-优缺点" tabindex="-1"><a class="header-anchor" href="#_26-面试官-说说你对函数式编程的理解-优缺点" aria-hidden="true">#</a> 26. 面试官：说说你对函数式编程的理解？优缺点？</h2><h2 id="_27-面试官-javascript-中如何实现函数缓存-函数缓存有哪些应用场景" tabindex="-1"><a class="header-anchor" href="#_27-面试官-javascript-中如何实现函数缓存-函数缓存有哪些应用场景" aria-hidden="true">#</a> 27. 面试官：Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？</h2><h2 id="_28-面试官-说说-javascript-数字精度丢失的问题-如何解决" tabindex="-1"><a class="header-anchor" href="#_28-面试官-说说-javascript-数字精度丢失的问题-如何解决" aria-hidden="true">#</a> 28. 面试官：说说 Javascript 数字精度丢失的问题，如何解决？</h2><h2 id="_29-面试官-什么是防抖和节流-有什么区别-如何实现" tabindex="-1"><a class="header-anchor" href="#_29-面试官-什么是防抖和节流-有什么区别-如何实现" aria-hidden="true">#</a> 29. 面试官：什么是防抖和节流？有什么区别？如何实现？</h2><h2 id="_30-面试官-如何判断一个元素是否在可视区域中" tabindex="-1"><a class="header-anchor" href="#_30-面试官-如何判断一个元素是否在可视区域中" aria-hidden="true">#</a> 30. 面试官：如何判断一个元素是否在可视区域中？</h2><h2 id="_31-面试官-大文件上传如何做断点续传" tabindex="-1"><a class="header-anchor" href="#_31-面试官-大文件上传如何做断点续传" aria-hidden="true">#</a> 31. 面试官：大文件上传如何做断点续传？</h2><h2 id="_32-面试官-如何实现上拉加载-下拉刷新" tabindex="-1"><a class="header-anchor" href="#_32-面试官-如何实现上拉加载-下拉刷新" aria-hidden="true">#</a> 32. 面试官：如何实现上拉加载，下拉刷新？</h2><h2 id="_33-面试官-什么是单点登录-如何实现" tabindex="-1"><a class="header-anchor" href="#_33-面试官-什么是单点登录-如何实现" aria-hidden="true">#</a> 33. 面试官：什么是单点登录？如何实现？</h2><h2 id="_34-面试官-web-常见的攻击方式有哪些-如何防御" tabindex="-1"><a class="header-anchor" href="#_34-面试官-web-常见的攻击方式有哪些-如何防御" aria-hidden="true">#</a> 34. 面试官：web 常见的攻击方式有哪些？如何防御？</h2><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/RhysZhao/interview-questions/edit/main/docs/base/js.md" rel="noopener noreferrer" target="_blank" aria-label="为该章节纠错"><!--[--><!--]--> 为该章节纠错 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 1009282428@qq.com">RhysZhao</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/interview-questions/base/" class="router-link-active" aria-label="前言"><!--[--><!--]--> 前言 <!--[--><!--]--></a></span><span class="next"><a href="/interview-questions/base/es6.html" class="" aria-label="ES6"><!--[--><!--]--> ES6 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/interview-questions/assets/app.572dc05b.js" defer></script>
  </body>
</html>
