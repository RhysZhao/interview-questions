<!--
 * Author  rhys.zhao
 * Date  2023-05-26 13:46:34
 * LastEditors  rhys.zhao
 * LastEditTime  2023-07-03 17:18:46
 * Description
-->

# 浏览器原理

## 浏览器的主要功能

浏览器的主要功能就是**发出请求，并在浏览器窗口展示你选择的网络资源**。这里的网络资源一般是指 HTML 文档，也可以是 PDF、图片或者其他类型。

## 进程与线程

进程：运行的程序实例。CPU 资源分配的最小单位。系统会分配独立的一块内存。

线程：CPU 调度的最小单位。不会分配内存。

可以这样理解：

进程好比是工厂。不同工厂之间是独立的。也就是说**各个进程间是独立的**。

线程好比是工人。**一个进程可以有一个或多个线程。同一进程下的多个线程共享内存**。

## 浏览器是多进程的

### 多进程的优势

浏览器是多进程的。这是出于以下两个方面的考虑：

1. **性能**

   多进程能够充分发挥多核 CPU 的优势。

2. **安全性、稳定性**

   **每个 Tab 页、插件都会开启一个独立的进程**。这样做可以：

   - 使用沙盒模型隔离插件进程，避免影响整个浏览器。
   - 避免单个 Tab 页、插件的崩溃影响整个浏览器。

### 浏览器的主要进程

下面介绍下浏览器的主要进程：

1. Browser 进程

浏览器进程。负责浏览器的主题部分，包括导航栏、书签、前进后退按钮等。

2. UI 进程

会有多个 UI 进程,主要负责绘制浏览器顶部按钮和导航栏输入框等组件，当你在导航栏里面输入一个 URL 的时候，其实就是 UI 线程在处理你的输入。

2. Network 进程

网络进程。负责页面的网络资源加载。

3. GPU 进程

图像渲染进程。它之所以被独立为一个进程是因为它要处理来自于不同 tab 的渲染请求并把它在同一个界面上画出来。

4. Plugins 进程

每种类型的插件对应一个进程，仅当使用该插件时才创建

5. Renderer 进程

浏览器渲染进程。默认每个 Tab 页面一个进程，互不影响。主要作用为页面渲染，脚本执行，事件处理等

6. Storage 进程

存储进程。

对于前端开发来说，我们比较关心的是 Renderer 进程。

## Renderer 进程

### 常驻线程

浏览器渲染进程是多线程的。一些常用的线程有：

1. GUI 渲染线程

负责渲染浏览器界面。包括解析 HTML,CSS,构建 DOM 树和 RenderObject 树，布局和绘制等。
当页面需要重绘和回流时，该线程就会执行

2. JS 引擎线程

负责运行 JS 脚本。一个 Tab 页中只有一个 JS 线程在运行 JS 程序(单线程)。

GUI 线程与 JS 线程互斥。JS 执行会导致 GUI 线程挂起。

这是因为 JS 可以操作 DOM，如果在修改元素的同时渲染页面，渲染线程前后获取的元素可能不一致。

3. 事件触发线程

当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中

当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理

注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）

4. 定时触发器线程
   传说中的 setInterval 与 setTimeout 所在线程

浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）

因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）

5. 异步 HTTP 请求线程

在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求

将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。

### Web Worker

对于密集型计算可以使用 Web Worker。Web Worker 为 Web 内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。

创建 Worker 时，JS 引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作 DOM）

JS 引擎线程与 worker 线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）

所以，如果有非常耗时的工作，请单独开一个 Worker 线程，这样里面不管如何翻天覆地都不会影响 JS 引擎主线程，
只待计算出结果后，将结果通信给主线程即可，perfect!
而且注意下，JS 引擎是单线程的，这一点的本质仍然未改变，Worker 可以理解是浏览器给 JS 引擎开的外挂，专门用来解决那些大量计算问题。

### Web Work 与 SharedWorker

既然都到了这里，就再提一下 SharedWorker（避免后续将这两个概念搞混）

WebWorker 只属于某个页面，不会和其他页面的 Render 进程（浏览器内核进程）共享

所以 Chrome 在 Render 进程中（每一个 Tab 页就是一个 render 进程）创建一个新的线程来运行 Worker 中的 JavaScript 程序。

SharedWorker 是浏览器所有页面共享的，不能采用与 Worker 同样的方式实现，因为它不隶属于某个 Render 进程，可以为多个 Render 进程共享使用

所以 Chrome 浏览器为 SharedWorker 单独创建一个进程来运行 JavaScript 程序，在浏览器中每个相同的 JavaScript 只存在一个 SharedWorker 进程，不管它被创建多少次。

看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker 由独立的进程管理，WebWorker 只是属于 render 进程下的一个线程

## 从输入 URL 到页面渲染出来经历了什么？

## 浏览器的渲染原理

## 浏览器缓存
